from typing import List, Dict, Optional
from app.models import CardType
import random

class ExtractionService:
    """
    Service for extracting cards from meeting transcripts.
    
    Currently uses placeholder logic. Will be replaced with actual LLM calls.
    """
    
    def extract_cards(
        self,
        transcript: str,
        agenda_items: Optional[List[str]],
        requested_types: List[CardType]
    ) -> List[Dict]:
        """
        Extract cards from transcript based on requested types.
        
        Args:
            transcript: The meeting transcript text
            agenda_items: Optional list of agenda items
            requested_types: Types of cards to extract
            
        Returns:
            List of card data dictionaries
        """
        # PLACEHOLDER: This will be replaced with actual LLM extraction
        # For now, generate some sample cards based on requested types
        
        cards = []
        position_offset = 0
        
        for card_type in requested_types:
            card = self._generate_placeholder_card(
                card_type,
                transcript,
                position_offset
            )
            if card:
                cards.append(card)
                position_offset += 1
        
        return cards
    
    def _generate_placeholder_card(
        self,
        card_type: CardType,
        transcript: str,
        position_index: int
    ) -> Dict:
        """Generate a placeholder card (to be replaced with LLM extraction)"""
        
        # Extract a snippet from transcript for demonstration
        words = transcript.split()
        snippet_length = min(50, len(words))
        snippet = " ".join(words[:snippet_length])
        if len(words) > snippet_length:
            snippet += "..."
        
        templates = {
            CardType.TLDR: {
                "title": "Meeting Summary",
                "content": f"TL;DR: This is a placeholder summary that will be generated by LLM. Based on: {snippet}"
            },
            CardType.TODO: {
                "title": "Action Items",
                "content": "TODO: Items will be extracted from transcript using LLM"
            },
            CardType.ACTION_ITEM: {
                "title": "Action Item",
                "content": "Specific action item extracted from meeting (placeholder)"
            },
            CardType.DECISION: {
                "title": "Decision Made",
                "content": "Key decisions from the meeting (placeholder)"
            },
            CardType.QUESTION: {
                "title": "Open Question",
                "content": "Questions raised during meeting (placeholder)"
            },
            CardType.DISCUSSION_POINT: {
                "title": "Discussion Point",
                "content": "Important discussion topic (placeholder)"
            },
            CardType.FOLLOW_UP: {
                "title": "Follow-up Required",
                "content": "Items requiring follow-up (placeholder)"
            }
        }
        
        if card_type not in templates:
            return None
        
        template = templates[card_type]
        
        return {
            "type": card_type,
            "title": template["title"],
            "content": template["content"],
            "segment": snippet,
            "position_x": (position_index % 3) * 300,  # Arrange in grid
            "position_y": (position_index // 3) * 200
        }
    
    def find_uncovered_agenda_items(
        self,
        agenda_items: List[str],
        transcript: str
    ) -> List[str]:
        """
        Find agenda items that were not covered in the meeting.
        
        Args:
            agenda_items: List of planned agenda items
            transcript: The meeting transcript
            
        Returns:
            List of uncovered agenda items
        """
        # PLACEHOLDER: Will use LLM to match agenda items to transcript
        # For now, do simple keyword matching
        
        uncovered = []
        transcript_lower = transcript.lower()
        
        for item in agenda_items:
            # Simple check: if none of the words in agenda item appear in transcript
            item_words = item.lower().split()
            if not any(word in transcript_lower for word in item_words if len(word) > 3):
                uncovered.append(item)
        
        return uncovered
    
    def extract_segment_for_card(
        self,
        transcript: str,
        card_content: str
    ) -> Optional[str]:
        """
        Find the relevant transcript segment for a card.
        
        Args:
            transcript: Full meeting transcript
            card_content: Content of the card
            
        Returns:
            Relevant transcript segment or None
        """
        # PLACEHOLDER: Will use LLM to find relevant segments
        # For now, return None
        return None
